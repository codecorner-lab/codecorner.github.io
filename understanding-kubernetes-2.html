<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Understanding Kubernetes - Part 2. - codecorner</title><meta name="description" content="Control Plane Components and Distributed Nature Kubernetes, being a distributed system, consists of several components that collaborate to maintain the desired state of the cluster. At its core are the control plane components, which manage and control the cluster's operation. The distributed nature of Kubernetes&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="./understanding-kubernetes-2.html"><link rel="stylesheet" href="./assets/css/style.css?v=6fbb1e8931a5afe843374fd67c192c86"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"./understanding-kubernetes-2.html"},"headline":"Understanding Kubernetes - Part 2.","datePublished":"2024-01-05T17:46","dateModified":"2024-01-05T17:49","description":"Control Plane Components and Distributed Nature Kubernetes, being a distributed system, consists of several components that collaborate to maintain the desired state of the cluster. At its core are the control plane components, which manage and control the cluster's operation. The distributed nature of Kubernetes&hellip;","author":{"@type":"Person","name":"Tebogo Mahlomoja","url":"./authors/tebogo-mahlomoja/"},"publisher":{"@type":"Organization","name":"Tebogo Mahlomoja"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="./">codecorner</a><div class="search"><div class="search__overlay js-search-overlay"><div class="search__overlay-inner"><button class="search__close js-search-close" aria-label="Close">Close</button></div></div><button class="search__btn js-search-btn" aria-label="Search"><svg role="presentation" focusable="false"><use xlink:href="./assets/svg/svg-map.svg#search"/></svg></button></div></header><main><article class="post"><div class="hero"><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2024-01-05T17:46">January 5, 2024</time></div><h1>Understanding Kubernetes - Part 2.</h1><div class="post__meta post__meta--author"><a href="./authors/tebogo-mahlomoja/" class="feed__author">Tebogo Mahlomoja</a></div></div></header></div><div class="wrapper post__entry"><h2 dir="auto" tabindex="-1">Control Plane Components and Distributed Nature</h2><p dir="auto">Kubernetes, being a distributed system, consists of several components that collaborate to maintain the desired state of the cluster. At its core are the control plane components, which manage and control the cluster's operation. The distributed nature of Kubernetes allows these components to work together across multiple nodes, ensuring high availability and fault tolerance.</p><h2 dir="auto" tabindex="-1">Control Plane Components</h2><h3 dir="auto" tabindex="-1">etcd</h3><p dir="auto"><strong>Description:</strong> etcd is a distributed key-value store that stores the cluster's configuration data, including cluster state, configurations, and metadata. It serves as Kubernetes' primary database and ensures high availability and consistency.</p><h3 dir="auto" tabindex="-1">API Server</h3><p dir="auto"><strong>Description:</strong> The API Server acts as the front-end for the Kubernetes control plane. It exposes the Kubernetes API, which allows users, other components, and external services to interact with the cluster. All administrative tasks and communication with other components occur through the API Server.</p><h3 dir="auto" tabindex="-1">Scheduler</h3><p dir="auto"><strong>Description:</strong> The Scheduler is responsible for assigning pods to nodes based on resource availability, constraints, policies, and workload requirements. It decides which node should run a particular pod, optimizing resource utilization and maintaining workload balance.</p><h3 dir="auto" tabindex="-1">Controller Manager</h3><p dir="auto"><strong>Description:</strong> The Controller Manager consists of multiple controllers that handle different aspects of the cluster's state. Each controller watches the cluster's state through the API Server and takes corrective actions to ensure that the actual state matches the desired state defined in the cluster's configuration.</p><h3 dir="auto" tabindex="-1">Distributed Nature of Kubernetes</h3><p dir="auto">Kubernetes operates in a distributed manner, meaning its components are spread across multiple nodes within the cluster. This distribution ensures fault tolerance and high availability by preventing a single point of failure. Each control plane component runs on multiple nodes, and when one node fails, another node automatically takes over its responsibilities.</p><h2 dir="auto" tabindex="-1">Control Loops and Reconciliation</h2><h3 dir="auto" tabindex="-1">Control Loops</h3><p dir="auto">Kubernetes employs control loops to maintain the desired state of the cluster continuously. These control loops are continuously running processes within each controller that perform reconciliation—comparing the actual state of the cluster with the desired state and taking necessary actions to converge them.</p><h3 dir="auto" tabindex="-1">Reconciliation Process</h3><ol dir="auto"><li><p dir="auto"><strong>Observation:</strong> Controllers watch the cluster's current state by querying the API Server for the desired configuration.</p></li><li><p dir="auto"><strong>Comparison:</strong> The observed state is compared against the desired state specified in the configuration.</p></li><li><p dir="auto"><strong>Decision Making:</strong> If there are any discrepancies between the observed and desired states, the controller makes decisions to reconcile the differences.</p></li><li><p dir="auto"><strong>Action:</strong> The controller takes appropriate actions to bring the actual state in line with the desired state, either by creating, deleting, or updating resources.</p></li></ol><h3 dir="auto" tabindex="-1">Example of Reconciliation</h3><p dir="auto">Consider the ReplicaSet controller, responsible for maintaining a specified number of identical pods. If it observes fewer pods than the desired count:</p><ul dir="auto"><li>Observation: The controller checks the actual number of pods.</li><li>Comparison: Compares this count with the desired count specified in the ReplicaSet.</li><li>Decision Making: Recognizes the shortfall and decides to create more pods.</li><li>Action: Initiates the creation of additional pods to meet the desired count.</li></ul><h3 dir="auto" tabindex="-1">Conclusion</h3><p dir="auto">The control plane components of Kubernetes work collaboratively in a distributed environment, ensuring the cluster's stability, fault tolerance, and adherence to the desired state. Through control loops and reconciliation processes, Kubernetes maintains the system's health by continuously monitoring and adjusting its components, thereby enabling a resilient and self-healing infrastructure for containerized applications. Understanding these control plane components and their distributed nature is crucial for managing and operating Kubernetes clusters effectively.</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on January 5, 2024</p><div class="post__share"><a href="https://www.linkedin.com/sharing/share-offsite/?url=%23PUBLII_RELATIVE_URL_BASE%23%2Funderstanding-kubernetes-2.html" class="js-share linkedin" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="./assets/svg/svg-map.svg#linkedin"/></svg> <span>LinkedIn</span></a></div><div class="post__bio bio"><div><h3 class="bio__name"><a href="./authors/tebogo-mahlomoja/" rel="author">Tebogo Mahlomoja</a></h3></div></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="./assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="./understanding-kubernetes.html" class="post__nav-link" rel="prev"><span>Previous</span> Understanding Kubernetes - Part 1.</a></div></div></nav><div class="post__related related"><div class="wrapper"><h2 class="h5 related__title">You should also read:</h2><article class="related__item"><div class="feed__meta"><time datetime="2024-01-05T17:08" class="feed__date">January 5, 2024</time></div><h3 class="h1"><a href="./understanding-kubernetes.html">Understanding Kubernetes - Part 1.</a></h3></article></div></div></main><footer class="footer"><div class="footer__copyright"><p>Powered by Publii</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg><use xlink:href="./assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script defer="defer" src="./assets/js/scripts.min.js?v=f47c11534595205f20935f0db2a62a85"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>