<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Understanding Kubernetes - Part 2. - Code Corner Softwares</title><meta name="description" content="Kubernetes Control Plane Kubernetes operates as a distributed system with multiple collaborating components dedicated to upholding the cluster's intended state. At its foundation lie the control plane components, pivotal in overseeing and governing the cluster's functionalities. Leveraging Kubernetes' distributed framework enables seamless collaboration among these&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="./understanding-kubernetes-2.html"><link rel="stylesheet" href="./assets/css/style.css?v=6fbb1e8931a5afe843374fd67c192c86"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"./understanding-kubernetes-2.html"},"headline":"Understanding Kubernetes - Part 2.","datePublished":"2024-01-05T17:46","dateModified":"2024-01-08T13:41","description":"Kubernetes Control Plane Kubernetes operates as a distributed system with multiple collaborating components dedicated to upholding the cluster's intended state. At its foundation lie the control plane components, pivotal in overseeing and governing the cluster's functionalities. Leveraging Kubernetes' distributed framework enables seamless collaboration among these&hellip;","author":{"@type":"Person","name":"Tebogo Mahlomoja","url":"./authors/tebogo-mahlomoja/"},"publisher":{"@type":"Organization","name":"Tebogo Mahlomoja"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="./">Code Corner Softwares</a><div class="search"><div class="search__overlay js-search-overlay"><div class="search__overlay-inner"><button class="search__close js-search-close" aria-label="Close">Close</button></div></div><button class="search__btn js-search-btn" aria-label="Search"><svg role="presentation" focusable="false"><use xlink:href="./assets/svg/svg-map.svg#search"/></svg></button></div></header><main><article class="post"><div class="hero"><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2024-01-05T17:46">January 5, 2024</time></div><h1>Understanding Kubernetes - Part 2.</h1><div class="post__meta post__meta--author"><a href="./authors/tebogo-mahlomoja/" class="feed__author">Tebogo Mahlomoja</a></div></div></header></div><div class="wrapper post__entry"><h2 dir="auto" tabindex="-1">Kubernetes Control Plane</h2><p dir="auto">Kubernetes operates as a distributed system with multiple collaborating components dedicated to upholding the cluster's intended state. At its foundation lie the control plane components, pivotal in overseeing and governing the cluster's functionalities. Leveraging Kubernetes' distributed framework enables seamless collaboration among these components across various nodes, ensuring robustness through high availability and fault tolerance measures.<br><br>To put it into perspective, when managing a data center, you handle an array of infrastructure elements like servers, switches, routers, firewalls, and load balancers at the hardware level. The challenge lies in exposing this infrastructure to developers and consumers without granting administrative access. Kubernetes serves as a solution by abstracting this complex infrastructure into an accessible API, effectively opening it up for utilization by anyone without necessitating direct administrative privileges.</p><h3 dir="auto" tabindex="-1">Distributed Nature of Kubernetes</h3><p dir="auto">Kubernetes operates in a distributed manner, meaning its components are spread across multiple nodes within the cluster. This distribution ensures fault tolerance and high availability by preventing a single point of failure. Each control plane component runs on multiple nodes, and when one node fails, another node automatically takes over its responsibilities.</p><div><ol><li><strong>API-driven interaction:</strong> Kubernetes offers an API that abstracts the details of individual servers, networking devices, and other infrastructure components. Users can interact with the Kubernetes API to manage applications, containers, storage, networking, and other resources without needing direct access to underlying hardware.</li><li><strong>Resource encapsulation:</strong> Kubernetes encapsulates infrastructure resources into higher-level objects like Pods, Services, Deployments, and ConfigMaps. These abstracted objects hide the complexity of the underlying infrastructure, allowing users to focus on defining the desired state of their applications rather than worrying about hardware specifics.</li><li><strong>Role-Based Access Control (RBAC):</strong> Kubernetes provides RBAC, enabling administrators to define granular access policies. This allows them to control who can perform which actions on various resources within the Kubernetes cluster. With RBAC, developers and consumers can access only the specific resources they need, ensuring security and minimizing potential risks.</li><li><strong>Service exposure and networking:</strong> Kubernetes abstracts networking complexities by providing Services, which act as an abstraction for network endpoints. Developers can expose their applications using Services without needing to manage individual load balancers or networking configurations.</li></ol></div><h2 dir="auto" tabindex="-1">Control Loops and Reconciliation</h2><h3 dir="auto" tabindex="-1">Control Loops</h3><p dir="auto">Kubernetes employs control loops to maintain the desired state of the cluster continuously. These control loops are continuously running processes within each controller that perform reconciliation—comparing the actual state of the cluster with the desired state and taking necessary actions to converge them.</p><h3 dir="auto" tabindex="-1">Reconciliation Process</h3><ol dir="auto"><li><p dir="auto"><strong>Observation:</strong> Controllers watch the cluster's current state by querying the API Server for the desired configuration.</p></li><li><p dir="auto"><strong>Comparison:</strong> The observed state is compared against the desired state specified in the configuration.</p></li><li><p dir="auto"><strong>Decision Making:</strong> If there are any discrepancies between the observed and desired states, the controller makes decisions to reconcile the differences.</p></li><li><p dir="auto"><strong>Action:</strong> The controller takes appropriate actions to bring the actual state in line with the desired state, either by creating, deleting, or updating resources.</p></li></ol><h3 dir="auto" tabindex="-1">Example of Reconciliation</h3><p dir="auto">Consider the ReplicaSet controller, responsible for maintaining a specified number of identical pods. If it observes fewer pods than the desired count:</p><ul dir="auto"><li>Observation: The controller checks the actual number of pods.</li><li>Comparison: Compares this count with the desired count specified in the ReplicaSet.</li><li>Decision Making: Recognizes the shortfall and decides to create more pods.</li><li>Action: Initiates the creation of additional pods to meet the desired count.</li></ul><h3 dir="auto" tabindex="-1">Conclusion</h3><p dir="auto">The control plane components of Kubernetes work collaboratively in a distributed environment, ensuring the cluster's stability, fault tolerance, and adherence to the desired state. Through control loops and reconciliation processes, Kubernetes maintains the system's health by continuously monitoring and adjusting its components, thereby enabling a resilient and self-healing infrastructure for containerized applications.</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on January 8, 2024</p><div class="post__share"><a href="https://www.linkedin.com/sharing/share-offsite/?url=%23PUBLII_RELATIVE_URL_BASE%23%2Funderstanding-kubernetes-2.html" class="js-share linkedin" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="./assets/svg/svg-map.svg#linkedin"/></svg> <span>LinkedIn</span></a></div><div class="post__bio bio"><div><h3 class="bio__name"><a href="./authors/tebogo-mahlomoja/" rel="author">Tebogo Mahlomoja</a></h3></div></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="./assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="./understanding-kubernetes.html" class="post__nav-link" rel="prev"><span>Previous</span> Understanding Kubernetes - Part 1.</a></div></div></nav><div class="post__related related"><div class="wrapper"><h2 class="h5 related__title">You should also read:</h2><article class="related__item"><div class="feed__meta"><time datetime="2024-01-05T17:08" class="feed__date">January 5, 2024</time></div><h3 class="h1"><a href="./understanding-kubernetes.html">Understanding Kubernetes - Part 1.</a></h3></article></div></div></main><footer class="footer"><div class="footer__copyright"><p>Powered by Publii</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg><use xlink:href="./assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script defer="defer" src="./assets/js/scripts.min.js?v=f47c11534595205f20935f0db2a62a85"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>